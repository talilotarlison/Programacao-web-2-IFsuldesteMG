A sua consulta SQL que voc√™ forneceu tem um pequeno erro de sintaxe, pois a instru√ß√£o `SELECT INTO` √© usada de forma incorreta. Para realizar uma consulta no banco de dados que busque transa√ß√µes pelo nome e tipo (onde o tipo √© selecionado pelo usu√°rio), a consulta seria algo como:

```sql
SELECT nome, valor, tipo, data 
FROM transacoes
WHERE nome = :nome
AND tipo = :tipo;
```

No seu c√≥digo PHP, voc√™ deve fazer a prepara√ß√£o da consulta e passar os par√¢metros dinamicamente. A consulta PHP ficaria assim:

```php
// Prepare the SQL query
$stmt = $this->db->prepare("SELECT nome, valor, tipo, data FROM transacoes WHERE nome = :nome AND tipo = :tipo");

// Bind the parameters to the query
$stmt->bindParam(':nome', $nome);
$stmt->bindParam(':tipo', $tipo);

// Execute the query
$stmt->execute();

// Fetch results
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);
```

Aqui est√° o que acontece:

* `:nome` e `:tipo` s√£o par√¢metros que ser√£o substitu√≠dos dinamicamente pelo PHP.
* `$nome` e `$tipo` s√£o as vari√°veis que voc√™ deve passar com os valores que o usu√°rio selecionar.

### Exemplo de como passar os valores

Por exemplo, se voc√™ pegar os valores dos inputs do formul√°rio, voc√™ poderia fazer algo como:

```php
$nome = $_POST['nome']; // ou qualquer outro m√©todo para pegar o valor
$tipo = $_POST['tipo']; // valor selecionado pelo usu√°rio

// Execute a consulta com os valores
$stmt->execute();
```

Isso retornar√° todas as transa√ß√µes que correspondem ao nome e tipo escolhidos pelo usu√°rio.

Se voc√™ precisar de mais alguma coisa ou se tiver outro tipo de quest√£o, me avise!


Para realizar uma busca com um nome que contenha uma parte do texto (ou seja, buscando por nomes que **cont√™m** o texto informado), voc√™ pode usar a cl√°usula `LIKE` do SQL junto com os caracteres de coringa `%`. O `%` permite que voc√™ fa√ßa uma busca por qualquer string que contenha o termo informado, independentemente do que esteja antes ou depois do texto.

A consulta SQL ficaria assim:

```sql
SELECT nome, valor, tipo, data 
FROM transacoes 
WHERE nome LIKE :nome AND tipo = :tipo;
```

No seu c√≥digo PHP, voc√™ pode ajustar o par√¢metro `:nome` para incluir o `%` antes e depois do valor que o usu√°rio fornecer, assim:

```php
// Prepare the SQL query
$stmt = $this->db->prepare("SELECT nome, valor, tipo, data FROM transacoes WHERE nome LIKE :nome AND tipo = :tipo");

// Adiciona os coringas % ao redor do nome fornecido pelo usu√°rio
$nome = '%' . $nome . '%'; // Aqui voc√™ coloca os coringas antes e depois do valor

// Bind the parameters to the query
$stmt->bindParam(':nome', $nome);
$stmt->bindParam(':tipo', $tipo);

// Execute the query
$stmt->execute();

// Fetch results
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);
```

### O que mudou:

* O par√¢metro `:nome` foi ajustado para incluir `%` antes e depois do valor que o usu√°rio fornecer (`$nome = '%' . $nome . '%'`).
* Isso faz com que a consulta busque qualquer transa√ß√£o cujo `nome` contenha o texto fornecido, independentemente do que esteja antes ou depois.

### Exemplos:

1. Se o usu√°rio digitar **"carro"**, a consulta buscar√° todos os nomes que contenham **"carro"**, como "carro", "carro el√©trico", "carro antigo", etc.
2. Se o usu√°rio digitar **"el√©trico"**, a consulta buscar√° todos os nomes que contenham **"el√©trico"**, como "carro el√©trico", "bicicleta el√©trica", etc.

Se precisar de mais algum ajuste ou ajuda, s√≥ avisar!
Se a consulta est√° retornando apenas o valor `1`, pode ser que o problema esteja na maneira como voc√™ est√° lidando com os resultados ou na forma como est√° executando a consulta. Vamos revisar e corrigir o c√≥digo de forma mais detalhada para garantir que tudo esteja funcionando corretamente.

Aqui est√° um passo a passo para depurar e garantir que o processo esteja correto:

### 1. Verifique a execu√ß√£o da consulta

Antes de mais nada, precisamos garantir que a consulta esteja sendo executada corretamente. O valor `1` pode estar relacionado a um erro que n√£o est√° sendo mostrado.

Tente adicionar algum tratamento de erro no seu c√≥digo, assim:

```php
try {
    // Prepare the SQL query
    $stmt = $this->db->prepare("SELECT nome, valor, tipo, data FROM transacoes WHERE nome LIKE :nome AND tipo = :tipo");

    // Adiciona os coringas ao redor do nome
    $nome = '%' . $nome . '%'; // Nome do usu√°rio com '%'

    // Bind the parameters to the query
    $stmt->bindParam(':nome', $nome);
    $stmt->bindParam(':tipo', $tipo);

    // Execute the query
    $stmt->execute();

    // Fetch results
    $results = $stmt->fetchAll(PDO::FETCH_ASSOC);

    // Verifica se retornou resultados
    if ($results) {
        echo "<pre>";
        print_r($results); // Isso vai mostrar os dados retornados pela consulta
        echo "</pre>";
    } else {
        echo "Nenhuma transa√ß√£o encontrada!";
    }

} catch (PDOException $e) {
    echo "Erro ao executar a consulta: " . $e->getMessage();
}
```

Isso ajudar√° a capturar erros e mostrar os dados ou uma mensagem de erro adequada.

### 2. Verifique se h√° dados correspondentes na tabela

√â poss√≠vel que a consulta n√£o esteja retornando resultados porque n√£o h√° dados que correspondam ao crit√©rio fornecido. Tente rodar a consulta diretamente no seu banco de dados com valores conhecidos para ver se retorna algum resultado. Exemplo:

```sql
SELECT nome, valor, tipo, data FROM transacoes WHERE nome LIKE '%carro%' AND tipo = 'tipo_especifico';
```

Isso ajuda a verificar se o problema est√° na consulta ou no c√≥digo PHP.

### 3. Verifique se as vari√°veis `:nome` e `:tipo` est√£o corretas

Certifique-se de que as vari√°veis `$nome` e `$tipo` est√£o sendo passadas corretamente para a consulta. Por exemplo, se os dados n√£o est√£o sendo enviados corretamente para o banco de dados, a consulta pode n√£o retornar nenhum valor. Verifique o conte√∫do dessas vari√°veis antes de fazer a consulta:

```php
echo "Nome: " . $nome . "<br>";
echo "Tipo: " . $tipo . "<br>";
```

### 4. Confirmando o m√©todo `fetchAll`

O m√©todo `fetchAll` deve retornar um array de resultados. Se a consulta n√£o encontrar nada, o retorno ser√° um array vazio. Se `fetchAll` estiver retornando `1`, pode ser que voc√™ esteja acessando os dados de forma incorreta.

No c√≥digo acima, o `print_r($results)` deve exibir os resultados. Se estiver retornando vazio ou com o valor `1`, √© poss√≠vel que a consulta n√£o tenha encontrado correspond√™ncia para o nome e tipo que voc√™ est√° passando.

### 5. Depura√ß√£o adicional

Tente rodar a consulta de forma mais simples para ver se o problema √© com o filtro `LIKE`:

```php
$stmt = $this->db->prepare("SELECT nome, valor, tipo, data FROM transacoes WHERE tipo = :tipo");
$stmt->bindParam(':tipo', $tipo);
$stmt->execute();
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);
```

Isso vai verificar se o filtro de tipo est√° funcionando corretamente sem o `LIKE`.

### Resumo:

1. Adicione o bloco `try-catch` para capturar e mostrar erros.
2. Verifique se os valores passados para `$nome` e `$tipo` est√£o corretos.
3. Verifique se h√° dados correspondentes no banco com a consulta direta.
4. Use `print_r($results)` para visualizar os dados retornados.

Se nada disso funcionar, voc√™ pode compartilhar mais detalhes do erro ou do comportamento observado, e eu posso ajudar a depurar mais a fundo!

No SQLite, para usar a cl√°usula `LIKE` com o operador coringa `%` para buscar uma correspond√™ncia parcial no campo `nome`, a sintaxe correta seria a seguinte:

```sql
SELECT id, nome, valor, tipo, data 
FROM transacoes 
WHERE nome LIKE '%leidiane%';
```

Aqui, o `%` antes e depois de `'leidiane'` √© o coringa que faz a busca parcial. O SQL ir√° encontrar todos os registros que tenham o nome contendo "leidiane", independentemente do que venha antes ou depois dessa string.

### Detalhes:

* **`LIKE '%leidiane%'`**: Isso buscar√° todas as transa√ß√µes onde o campo `nome` contenha a palavra "leidiane" em qualquer parte do nome.
* O `=` n√£o √© necess√°rio, pois o `LIKE` j√° √© utilizado para comparar partes de strings.

### Como ficaria no c√≥digo PHP:

Aqui est√° um exemplo de como voc√™ pode usar essa consulta no seu c√≥digo PHP:

```php
// Preparando a consulta SQL com LIKE para buscar por nome parcialmente
$stmt = $this->db->prepare("SELECT id, nome, valor, tipo, data FROM transacoes WHERE nome LIKE :nome");

// Adicionando os coringas ao redor do nome para a busca parcial
$nome = '%' . $nome . '%'; // Adiciona '%' antes e depois do nome

// Bind do par√¢metro
$stmt->bindParam(':nome', $nome);

// Executando a consulta
$stmt->execute();

// Pegando os resultados
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);

// Verificando se h√° resultados
if ($results) {
    echo "<pre>";
    print_r($results); // Mostra os dados retornados pela consulta
    echo "</pre>";
} else {
    echo "Nenhuma transa√ß√£o encontrada!";
}
```

No c√≥digo acima:

* A vari√°vel `$nome` √© modificada para incluir `%` antes e depois da string, permitindo uma busca parcial.
* A consulta SQL agora usa `LIKE :nome` para buscar qualquer transa√ß√£o cujo nome contenha o valor de `$nome`.

### Teste com `LIKE` no SQLite:

Voc√™ pode rodar a consulta diretamente no SQLite da seguinte forma:

```sql
SELECT id, nome, valor, tipo, data 
FROM transacoes 
WHERE nome LIKE '%leidiane%';
```

Isso deve retornar todas as transa√ß√µes onde o campo `nome` contenha "leidiane".

Se ainda tiver algum problema ou se precisar de mais detalhes, me avise!
A consulta que voc√™ escreveu tem um pequeno erro de sintaxe. No SQL, quando voc√™ usa o operador `LIKE`, n√£o deve repetir a coluna `nome` duas vezes. O correto seria utilizar apenas `nome LIKE :nome`.

Aqui est√° o c√≥digo corrigido:

```php
$stmt = $this->db->prepare("SELECT id, nome, valor, tipo, data FROM transacoes WHERE nome LIKE :nome");
```

Al√©m disso, voc√™ precisa garantir que o par√¢metro `:nome` seja passado corretamente com os coringas `%` para a busca parcial. Veja como o c√≥digo completo ficaria:

### C√≥digo corrigido completo:

```php
// Adicionando os coringas '%' ao redor do nome para busca parcial
$nome = '%' . $nome . '%';

// Preparando a consulta SQL com LIKE
$stmt = $this->db->prepare("SELECT id, nome, valor, tipo, data FROM transacoes WHERE nome LIKE :nome");

// Associando o valor do par√¢metro
$stmt->bindParam(':nome', $nome);

// Executando a consulta
$stmt->execute();

// Obtendo os resultados
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);

// Verificando se h√° resultados
if ($results) {
    echo "<pre>";
    print_r($results); // Mostra os dados retornados pela consulta
    echo "</pre>";
} else {
    echo "Nenhuma transa√ß√£o encontrada!";
}
```

### O que mudou:

* **`nome LIKE :nome`**: Agora o `LIKE` √© usado corretamente para buscar partes do nome.
* **`$nome = '%' . $nome . '%'`**: Aqui, os coringas `%` s√£o adicionados antes e depois do nome, permitindo buscar qualquer nome que contenha a string fornecida.

### Resumo:

* **`LIKE`** √© usado para buscar correspond√™ncias parciais.
* Voc√™ s√≥ precisa usar **`nome LIKE :nome`**, sem repetir a coluna `nome`.

Se precisar de mais ajuda ou quiser fazer outros ajustes, √© s√≥ avisar!

A sua consulta:

```sql
SELECT id, nome, valor, tipo, data FROM transacoes WHERE valor LIKE '88'
```

est√° **sintaticamente correta**, mas o uso de `LIKE` s√≥ faz sentido quando voc√™ est√° lidando com **strings** e quer fazer **busca parcial ou com curingas**, como:

```sql
valor LIKE '%88%'
```

### üëâ Se o campo `valor` √© **num√©rico**, voc√™ **n√£o deve usar `LIKE`**, mas sim uma compara√ß√£o direta:

```sql
-- Busca valores exatamente iguais a 88
SELECT id, nome, valor, tipo, data 
FROM transacoes 
WHERE valor = 88;
```

### üëâ Se voc√™ quiser encontrar valores que **contenham 88** dentro (como 188, 880, 2880), **s√≥ faz sentido se o campo `valor` for texto**:

```sql
-- Apenas se 'valor' for um campo de texto (VARCHAR, TEXT)
SELECT id, nome, valor, tipo, data 
FROM transacoes 
WHERE valor LIKE '%88%';
```

---

### ‚úÖ Recomenda√ß√µes:

1. **Se `valor` √© num√©rico (prov√°vel em transa√ß√µes)**:

   * Use `=` ou operadores como `>`, `<`, `BETWEEN`, etc.
   * Exemplo:

     ```sql
     SELECT * FROM transacoes WHERE valor = 88;
     ```

2. **Se `valor` √© texto (n√£o recomendado para n√∫meros)**:

   * Use `LIKE '%88%'` se quiser buscar onde o n√∫mero aparece como parte da string.

---

Se voc√™ n√£o tem certeza se o campo `valor` √© `TEXT` ou `NUMERIC`, use este comando no SQLite para checar a estrutura da tabela:

```sql
PRAGMA table_info(transacoes);
```

Isso vai mostrar os nomes dos campos e seus tipos.

Se quiser ajuda para adaptar a busca conforme o tipo real da coluna, posso te ajudar com isso tamb√©m.


```php
 if ($busca && $tipo) {
                    if (empty($busca)) {
                        $error = "Dados da transa√ß√£o √© obrigat√≥rio.";
                    } elseif (empty($tipo) || !in_array($tipo, ['nome', 'valor', 'tipo'])) {
                        $error = "O tipo de transa√ß√£o √© inv√°lido.";
                    }

                    if($tipo == 'nome'){
                        try {
                            $results = $buscaModel->buscaTransacaoNome($busca);
                            if ($results) {
                                $buscaTransacao = $results; // Isso vai mostrar os dados retornados pela consulta
                            } else {
                                $error = "Nenhuma transa√ß√£o encontrada!";
                            }
                         }catch (PDOException $e) {
                            echo "Erro ao executar a consulta: " . $e->getMessage();
                         }
                    }else if($tipo == 'tipo'){
                        try {
                            $results = $buscaModel->buscaTransacaoTipo($busca);
                            if ($results) {
                                $buscaTransacao = $results; // Isso vai mostrar os dados retornados pela consulta
                            } else {
                                $error = "Nenhuma transa√ß√£o encontrada!";
                            }
                         }catch (PDOException $e) {
                            echo "Erro ao executar a consulta: " . $e->getMessage();
                         }
                    }else if($tipo == 'valor'){
                        try {
                            $results = $buscaModel->buscaTransacaoValor($busca);
                            if ($results) {
                                $buscaTransacao = $results; // Isso vai mostrar os dados retornados pela consulta
                            } else {
                                $error = "Nenhuma transa√ß√£o encontrada!";
                            }
                         }catch (PDOException $e) {
                            echo "Erro ao executar a consulta: " . $e->getMessage();
                         }
                    }
                }
            } 
```

Claro! Seu c√≥digo est√° funcional, mas pode ser **refatorado para reduzir duplica√ß√£o**, **melhorar a legibilidade** e **organizar melhor os blocos condicionais**. Aqui est√° uma sugest√£o de refatora√ß√£o:

---

### ‚úÖ Refatora√ß√£o:

```php
if ($busca && $tipo) {
    // Valida√ß√£o de entrada
    if (empty($busca)) {
        $error = "Dados da transa√ß√£o s√£o obrigat√≥rios.";
    } elseif (!in_array($tipo, ['nome', 'valor', 'tipo'])) {
        $error = "O tipo de transa√ß√£o √© inv√°lido.";
    } else {
        // Mapeia os m√©todos dispon√≠veis por tipo
        $metodosBusca = [
            'nome'  => 'buscaTransacaoNome',
            'tipo'  => 'buscaTransacaoTipo',
            'valor' => 'buscaTransacaoValor'
        ];

        // Verifica se existe um m√©todo correspondente
        if (array_key_exists($tipo, $metodosBusca)) {
            try {
                $metodo = $metodosBusca[$tipo];
                $results = $buscaModel->$metodo($busca);

                if ($results) {
                    $buscaTransacao = $results;
                } else {
                    $error = "Nenhuma transa√ß√£o encontrada!";
                }
            } catch (PDOException $e) {
                echo "Erro ao executar a consulta: " . $e->getMessage();
            }
        }
    }
}
```

---

### ‚úÖ Melhorias aplicadas:

* **Evita repeti√ß√£o de c√≥digo** (`try/catch`, `if ($results)`, etc.).
* **Organiza os m√©todos em um array associativo** para facilitar a manuten√ß√£o e reduzir `if`/`else`.
* **Clareza na valida√ß√£o dos par√¢metros**.
* **Uso correto de `array_key_exists`** para garantir que o m√©todo exista.

---

Se quiser deixar ainda mais elegante, pode mover a valida√ß√£o para fora do `if ($busca && $tipo)` e colocar tudo de forma sequencial.

Se quiser, posso tamb√©m sugerir como fazer isso com **Switch**, **Factory Pattern** ou **Polimorfismo** se estiver usando POO.

Deseja uma dessas vers√µes tamb√©m?
